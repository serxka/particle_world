use core::ops::RangeInclusive;

use rand::{rngs::SmallRng, Rng, SeedableRng};
use rand_distr::Alphanumeric;
use rand_seeder::Seeder;

mod error;
pub mod kinds;
mod math;
pub mod particle;

pub use error::Error;
use kinds::Kinds;
use particle::Particle;

pub(crate) const WORLD_SIZE: f32 = 1.0;

/// A list of parameters that control how the world acts and the type of particles
/// that can be generated and spawned
pub struct Parameters {
	/// Whether the world should wrap particles around from one side of the world to
	/// the other. If this is turned off particles will collide with wall and experience
	/// some loss in velocity as they reflect off.
	pub wrap: bool,
	/// What percentage of velocity is lost every step. Calculated as `velocity * (1.0 - friction)`.
	pub friction: f32,
	/// Amount of particles in the world
	pub particle_count: usize,
	/// How many different types of particles there are
	pub kinds_count: usize,
	/// The seed in which RNG is seeded off of, this deterministically defines every
	/// action that occurs within the world lifetime. Expect new seeds generated by
	/// `World::reseed()`.
	pub seed: String,
	/// Range in which particles may have their radius set to, based on *kind* of
	/// particle rather than individual particle.
	pub radius: RangeInclusive<f32>,
}

impl core::default::Default for Parameters {
	fn default() -> Parameters {
		Parameters {
			wrap: false,
			friction: 0.05,
			particle_count: 150,
			kinds_count: 6,
			seed: String::new(),
			radius: 1.0..=1.0,
		}
	}
}

/// Stores the whole state of the world
pub struct World {
	pub kinds: Kinds,
	pub particles: Vec<Particle>,
	pub parameters: Parameters,
	rng: SmallRng,
}

impl World {
	/// Creates a new world based of a set of parameters.
	///
	/// ```
	/// let para = Parameters::default();
	/// let mut world = World::new(para);
	/// loop {
	/// 	world.step();
	/// }
	pub fn new(mut para: Parameters) -> World {
		if para.seed.is_empty() {
			para.seed = generate_seed();
		}
		let mut rng = Seeder::from(&para.seed).make_rng();
		let kinds = generate_kinds(&mut rng, &para);
		let particles = generate_particles(&mut rng, &para, &kinds);

		World {
			kinds,
			particles,
			parameters: para,
			rng,
		}
	}

	/// Create a new world with parameters as read from the seed input. You
	/// can create this `seed` string by calling `World::export` on another
	/// `World`. Returns an error if the
	pub fn from(seed: &str) -> Result<World, Error> {
		let para = deser_seed(seed)?;
		let mut rng = Seeder::from(&para.seed).make_rng();
		let kinds = generate_kinds(&mut rng, &para);
		let particles = generate_particles(&mut rng, &para, &kinds);

		Ok(World {
			kinds,
			particles,
			parameters: para,
			rng,
		})
	}

	/// Export the current parameters as a seed which can then be loaded later on
	pub fn export(&self) -> String {
		ser_seed(&self.parameters)
	}

	/// Using the current world and it's parameters, regenerate a seed and then
	/// repopulate the world using this new seed.
	pub fn reseed(&mut self) {
		// Set new seed
		let seed = generate_seed();
		let mut rng = Seeder::from(&seed).make_rng();
		self.parameters.seed = seed;

		// Regenerate particles and types
		let kinds = generate_kinds(&mut rng, &self.parameters);
		let particles = generate_particles(&mut rng, &self.parameters, &kinds);

		self.particles = particles;
		self.kinds = kinds;
		self.rng = rng;
	}

	/// Step the world forward a single tick
	pub fn step(&mut self) {
		for i in 0..self.particles.len() {
			let mut a = self.particles[i].clone();
			self.influence(&mut a);
			self.particles[i] = a;
		}
	}

	fn influence(&self, a: &mut Particle) {
		for b in self.particles.iter() {
			// Difference between two particles
			let mut dp = a.pos - b.pos;

			// Range in which attraction can occur
			let r = 0.4; // PLACEHOLDER

			// Distance between particles squared
			let dis2 = dp.x * dp.x + dp.y * dp.y;
			// Check if outside of range or super close (same particle)
			if dis2 > r * r || dis2 < 0.00001 {
				continue;
			}

			let dis = f32::sqrt(dis2);
			dp /= dis;

			let mut f;
			let pow = 1.0;
			if dis > a.rad * 2.0 + b.rad * 2.0 {
				f = (1.0 / dis2) * pow;
			} else {
				f = (1.0 / dis2) * -pow;
			}
			f = f32::min(f, 0.01);

			a.vel += dp * f;
		}
	}
}

fn generate_kinds(_rng: &mut SmallRng, _para: &Parameters) -> Kinds {
	unimplemented!()
}

fn generate_particles(_rng: &mut SmallRng, _para: &Parameters, _kinds: &Kinds) -> Vec<Particle> {
	unimplemented!()
}

fn deser_seed(seed: &str) -> Result<Parameters, Error> {
	let s = base64::decode(seed).map_err(|_| Error::SeedInvalidCharacter)?;
	let s = String::from_utf8_lossy(&s);
	let _s = s.split(";");
	unimplemented!()
}

fn ser_seed(para: &Parameters) -> String {
	let out = format!(
		"{};{};{}..{};{}",
		if para.wrap { 1 } else { 0 },
		para.friction,
		para.radius.start(),
		para.radius.end(),
		para.seed
	);
	base64::encode(&out)
}

fn generate_seed() -> String {
	let mut rng = SmallRng::from_rng(rand::thread_rng()).unwrap();
	core::iter::repeat(())
		.map(|_| rng.sample(Alphanumeric))
		.map(char::from)
		.take(8)
		.collect()
}
